<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>School of Rock Setlist Tracker</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
 <style>
  body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
  }
  .container {
      width: 100%;
      margin: 0 auto;
      background: white;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      padding: 20px;
  }
  h1 {
      text-align:center;
      margin-bottom:15px;
      font-weight:300;
  }
  #timerDisplay {
      font-size:3em;
      font-weight:bold;
      text-align:center;
      display:block;
      margin:10px 0;
  }
  #currentSongDisplay {
      font-size:2.2em;
      font-weight:bold;
      text-align:center;
      margin:20px 0 5px;
  }
  #songNotesDisplay {
      text-align:center;
      font-size:1.1em;
      margin-bottom:5px;
  }
  #nextSongDisplay {
      font-size:1.3em;
      text-align:center;
      margin-bottom:15px;
      color:#555;
  }
  #progressContainer {
      height:20px;
      background:#e2e8f0;
      border-radius:10px;
      overflow:hidden;
      margin:10px 0;
  }
  #progressBar {
      height:100%;
      width:0%;
      background:#4caf50;
      transition:width 0.2s ease;
  }
  #aheadBehind {
      text-align:center;
      font-size:1.5em;
      margin:10px 0;
  }
  #clockTime,#projectedEnd,#droppedInfo,#transitionInfo{
      text-align:center;
      margin:4px 0;
      font-size:1em;
  }
  #clockTime,#projectedEnd{
      display:inline-block;
      margin:4px 8px;
  }
  #setlist { list-style:none; padding:0; }
  #setlist li {
      padding:12px;
      background:#f9f9f9;
      margin-bottom:8px;
      border-radius:8px;
      box-shadow:0 2px 4px rgba(0,0,0,0.05);
  }
  #setlist li.playing { background:#fff3cd; }
  #setlist li.should { background:#d1e7dd; }
  #setlist li.dropped { background:#f8d7da; text-decoration: line-through; opacity:0.6; }
.song-info { font-weight:bold; margin-bottom:5px; }
.song-controls{ display:flex; flex-wrap:wrap; align-items:center; gap:10px; }
.priority-label { font-size:0.9em; }
.protect-label { font-size:0.9em; }
.time { width:60px; text-align:right; }
 .runtime { width:60px; text-align:right; }
.bpm { width:70px; text-align:right; }
  #navControls{
      text-align:center;
      margin-bottom:15px;
  }
  #navControls button{
      font-size:1.5em;
      padding:15px 25px;
      margin:0 5px;
      background:#4caf50;
      color:white;
      border:none;
      border-radius:8px;
      cursor:pointer;
  }
  #navControls button:active{
      transform:scale(0.97);
  }
  .highlight{
      background:#ff9800 !important;
  }
  #metronomeControls{
      text-align:center;
      margin-top:auto;
      margin-bottom:10px;
  }
  #metronomeBeat{
      width:40px;
      height:40px;
      margin:10px auto;
      border-radius:50%;
      background:#4caf50;
      opacity:0.2;
      transition:opacity 0.1s;
  }
  #metronomeBeat.active{
      opacity:1;
  }
  #fileControls{
      margin-top:20px;
      text-align:center;
  }
  #fileControls .file-row{
      display:flex;
      flex-wrap:wrap;
      justify-content:center;
      align-items:center;
      margin-top:10px;
  }
  #fileControls label{
      margin:5px 10px;
      font-size:1.1em;
  }
  #fileControls input[type="number"]{
      width:4em;
  }

  #contentWrapper{
      display:flex;
      flex-direction:column;
      gap:20px;
  }
  #songsColumn{
      overflow-y:auto;
      max-height:60vh;
  }
  #infoColumn{
      display:flex;
      flex-direction:column;
  }
  #infoSpacer{
      flex-grow:1;
  }
  @media (min-width:800px){
      #contentWrapper{ flex-direction:row; align-items:flex-start; }
      #infoColumn{ flex:1; padding-right:20px; }
      #songsColumn{ flex:1; max-height:80vh; }
  }
  @media (max-width:600px){
      #navControls button{
          font-size:1.2em;
          padding:12px 20px;
      }
      #currentSongDisplay{ font-size:1.6em; }
      #nextSongDisplay{ font-size:1.1em; }
  }
</style>
</head>
<body>
<div class="container">
<div id="contentWrapper">
<div id="infoColumn">
<div id="navControls">
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="prevBtn">&lt;</button>
    <button id="nextBtn">&gt;</button>
    <button id="dropBtn">Drop Songs</button>
</div>
<div id="currentSongDisplay"></div>
<div id="songNotesDisplay" style="text-align:center;margin-bottom:5px;"></div>
<div id="nextSongDisplay"></div>
  <div id="progressContainer"><div id="progressBar"></div></div>
  <span id="timerDisplay">00:00</span>
  <div id="timeRemaining" style="text-align:center;margin-bottom:10px;"></div>
<div id="aheadBehind"></div>
<div id="clockTime"></div>
<div id="projectedEnd"></div>
<div id="droppedInfo"></div>
<div id="transitionInfo"></div>
<div id="infoSpacer"></div>
  <div id="metronomeControls">
      <label><input type="checkbox" id="metronomeToggle"></label>
      <label>BPM: <input type="number" id="bpmInput" value="120" min="30" style="width:5em"></label>
      <div id="metronomeBeat"></div>
  </div>
</div> <!-- infoColumn -->
<div id="songsColumn">
<ul id="setlist"></ul>
</div>
</div> <!-- contentWrapper -->
<div id="fileControls">
    <div class="file-row">
        <input type="file" id="csvFile" accept=".csv">
    </div>
    <div class="file-row">
        <label>Max Time (min): <input type="number" id="maxTime" value="60" min="1"></label>
        <label>End By: <input type="time" id="endBy"></label>
        <label>Transition (sec): <input type="number" id="transitionTime" value="60" min="0"></label>
        <label><input type="checkbox" id="autoDrop"> Auto Drop</label>
    </div>
</div>
</div>
<script>
let songs = [];
let timer = null;
let startTime = null;
let currentIndex = 0;
let speedFactor = 1;
let songStart = 0; // actual start time (sec) of the current song
const startDiff = []; // difference of actual start vs scheduled start per song
let isPaused = false;
let pauseStart = 0;
let totalPause = 0; // accumulated pause time in ms
const actualStart = [];
const transitionDurations = [];
let autoDrop = false;
let currentBpm = 120;
let metronomeTimer = null;
let lastSongAppliedBpm = -1;

// Check query string for a debugging speed multiplier, e.g. ?debugspeed=5
// This is intentionally hidden so regular users don't accidentally change it.
const params = new URLSearchParams(window.location.search);
const dbg = parseFloat(params.get('debugspeed'));
if(dbg && dbg > 0) speedFactor = dbg;

function parseDuration(str){
    if(!str) return 0;
    str = String(str).trim();
    if(str.includes(':')){
        const parts = str.split(':').map(Number);
        if(parts.length===2){
            return parts[0]*60 + parts[1];
        } else if(parts.length===3){
            return parts[0]*3600 + parts[1]*60 + parts[2];
        }
    }
    if(/^[0-9.]+$/.test(str)) return parseFloat(str)*60;
    return 0;
}

function formatTime(sec){
    sec = Math.max(0, Math.floor(sec));
    const m = Math.floor(sec/60);
    const s = sec%60;
    return `${m}:${s.toString().padStart(2,'0')}`;
}

function getElapsedMs(){
    if(!startTime) return 0;
    let paused = totalPause;
    if(isPaused) paused += Date.now()-pauseStart;
    return Date.now() - startTime - paused;
}
  

function formatClock(date){
    return date.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
}

function startMetronome(){
    if(metronomeTimer) clearInterval(metronomeTimer);
    const beatEl=document.getElementById('metronomeBeat');
    if(!beatEl) return;
    const interval=60000/Math.max(1,currentBpm);
    metronomeTimer=setInterval(()=>{
        beatEl.classList.add('active');
        setTimeout(()=>beatEl.classList.remove('active'),100);
    },interval);
}

function stopMetronome(){
    if(metronomeTimer) clearInterval(metronomeTimer);
    metronomeTimer=null;
    const beatEl=document.getElementById('metronomeBeat');
    if(beatEl) beatEl.classList.remove('active');
}

function setMetronomeBpm(bpm){
    if(!bpm || isNaN(bpm)) return;
    currentBpm=parseInt(bpm);
    const inp=document.getElementById('bpmInput');
    if(inp) inp.value=currentBpm;
    const toggle=document.getElementById('metronomeToggle');
    if(toggle && toggle.checked) startMetronome();
}

function applySongBpm(){
    const song=songs[currentIndex];
    if(song && song.bpm && currentIndex!==lastSongAppliedBpm){
        setMetronomeBpm(song.bpm);
        lastSongAppliedBpm=currentIndex;
    }
}

document.getElementById('csvFile').addEventListener('change', e=>{
    const file = e.target.files[0];
    if(!file) return;
    Papa.parse(file, {
        header:true,
        skipEmptyLines:true,
        complete: res => { loadSongs(res.data); }
    });
});

function loadSongs(data){
    songs = [];
    if(timer){
        clearInterval(timer);
        timer=null;
    }
    startTime=null;
    isPaused=false;
    totalPause=0;
    currentIndex=0;
    data.forEach(row=>{
        const normalized = {};
        Object.keys(row).forEach(k=>{
            normalized[k.trim().toLowerCase()] = row[k];
        });
        const title = normalized['song'] || normalized['title'];
        const artist = normalized['artist'];
        const durField = normalized['duration'] || normalized['time'];
        const bpmField = normalized['bpm'] || normalized['tempo'];
        const notesField = normalized['notes'] || normalized['note'];
        if(!title && !artist) return; // ignore note rows
        songs.push({
            title: title || '',
            artist: artist || '',
            duration: parseDuration(durField),
            bpm: bpmField ? parseInt(bpmField) : null,
            notes: notesField || '',
            dropOrder:0,
            start:0,
            protect:false,
            dropped:false,
            manualDrop:false
        });
    });
    lastSongAppliedBpm=-1;
    if(songs.length && songs[0].bpm){
        setMetronomeBpm(songs[0].bpm);
        lastSongAppliedBpm=0;
    }
    renderSetlist();
    updateDisplay();
}

function renderSetlist(){
    const list=document.getElementById('setlist');
    list.innerHTML='';
    let cumulative=0;
    const transition=parseInt(document.getElementById('transitionTime').value)||0;
    songs.forEach((song,i)=>{
        song.start=cumulative;
        cumulative+=song.duration+transition;
        const li=document.createElement('li');
        li.dataset.index=i;
        li.innerHTML=`<div class="song-info"><label class="protect-label"><input type="checkbox" class="drop-toggle" data-idx="${i}" ${song.dropped?'':'checked'}></label> ${i+1}. ${song.title} - ${song.artist}</div>
            <div class="song-controls">
                <span class="runtime">${formatTime(song.start)}</span>
                <span class="time">${formatTime(song.duration)}</span>
                <span class="bpm">${song.bpm?song.bpm+' BPM':''}</span>
                <label class="priority-label">Drop <input type="number" class="drop-order" data-idx="${i}" min="0" value="${song.dropOrder}" style="width:3em"></label>
            </div>`;
        list.appendChild(li);
    });
    document.querySelectorAll('.drop-toggle').forEach(cb=>{
        cb.addEventListener('change',e=>{
            const idx=parseInt(e.target.dataset.idx);
            const checked=e.target.checked;
            songs[idx].dropped=!checked;
            songs[idx].manualDrop=!checked;
            if(autoDrop){
                const elapsed=startTime?Math.floor(getElapsedMs()/1000*speedFactor):0;
                computeDroppedSongs(elapsed);
            }
            updateDisplay();
        });
    });
    document.querySelectorAll('.drop-order').forEach(inp=>{
        inp.addEventListener('change',e=>{
            const idx=parseInt(e.target.dataset.idx);
            const val=parseInt(e.target.value);
            if(!isNaN(val) && val>=0) songs[idx].dropOrder=val;
        });
    });
    document.getElementById('timeRemaining').textContent='';
    updateDisplay();
}

function computeDroppedSongs(elapsed){
    const maxSec=parseInt(document.getElementById('maxTime').value)*60;
    const remaining=maxSec-elapsed;
    const transition=parseInt(document.getElementById('transitionTime').value)||0;

    songs.forEach(s=>{ if(!s.manualDrop) s.dropped=false; });

    const pending=[];
    for(let i=currentIndex;i<songs.length;i++){
        if(!songs[i].manualDrop) pending.push(i);
    }
    const droppable=pending.filter(i=>!songs[i].protect);

    const totalDur=idxs=>{
        let t=0;
        for(let j=0;j<idxs.length;j++){
            t+=songs[idxs[j]].duration;
            if(j<idxs.length-1) t+=transition;
        }
        return t;
    };

    let keep=[...pending];
    if(totalDur(keep)<=remaining) return;

    const closerIdx=songs.length-1;
    // Sort drop candidates so we always drop from the bottom first.
    const order=droppable.sort((a,b)=>{
        if(a===closerIdx && b!==closerIdx) return 1;
        if(b===closerIdx && a!==closerIdx) return -1;
        const da=songs[a].dropOrder??0;
        const db=songs[b].dropOrder??0;
        const pa=da===0?Infinity:da;
        const pb=db===0?Infinity:db;
        if(pa!==pb) return pa-pb;
        return b-a;
    });

    for(const idx of order){
        if(totalDur(keep)<=remaining) break;
        keep=keep.filter(k=>k!==idx);
        songs[idx].dropped=true;
        songs[idx].manualDrop=false;
    }
}

function updateDropBtn(elapsed){
    const btn=document.getElementById('dropBtn');
    if(!btn) return;
    if(autoDrop) btn.classList.remove('highlight');
    else btn.classList.add('highlight');

    const maxSec=parseInt(document.getElementById('maxTime').value)*60;
    const remaining=remainingDuration(true, elapsed); // use current dropped state
    const show=!autoDrop && (elapsed + remaining > maxSec);
    btn.style.display=show?'':'none';
}

function remainingDuration(withDrops, elapsed){
    const transition = parseInt(document.getElementById('transitionTime').value) || 0;
    const remainIdx = [];
    for(let i=currentIndex; i<songs.length; i++){
        if(withDrops && songs[i].dropped) continue;
        remainIdx.push(i);
    }
    let total = 0;
    remainIdx.forEach((idx,j)=>{
        total += songs[idx].duration;
        if(j < remainIdx.length-1) total += transition;
    });
    const curSongDur = songs[currentIndex] ? songs[currentIndex].duration : 0;
    const progress = Math.min(curSongDur, Math.max(0, elapsed - songStart));
    return Math.max(0, total - progress);
}

function updateDisplay(){
    const elapsed=startTime ? Math.floor(getElapsedMs()/1000*speedFactor) : 0;
    const realElapsed=startTime ? Math.floor(getElapsedMs()/1000) : 0;
    if(autoDrop) computeDroppedSongs(elapsed);
    updateDropBtn(elapsed);
    document.getElementById('timerDisplay').textContent=formatTime(elapsed);
    const maxSec=parseInt(document.getElementById('maxTime').value)*60;
    const setRemain=remainingDuration(true, elapsed);
    const gigRemain=Math.max(0, maxSec-elapsed);
    const remEl=document.getElementById('timeRemaining');
    if(remEl){
        remEl.textContent=`${formatTime(setRemain)} of ${formatTime(gigRemain)}`;
        remEl.style.color=setRemain>gigRemain?'red':'blue';
    }
    const progress=document.getElementById('progressBar');
    if(progress){
        progress.style.width=Math.min(100,elapsed/maxSec*100)+"%";
    }
    const curSong=songs[currentIndex];
    applySongBpm();
    const songEl=document.getElementById('currentSongDisplay');
    if(songEl){
        songEl.textContent=curSong?`${currentIndex+1}. ${curSong.title} - ${curSong.artist}`:'';
    }
    const notesEl=document.getElementById('songNotesDisplay');
    if(notesEl){
        notesEl.textContent=curSong && curSong.notes?curSong.notes:'';
    }
    const nextEl=document.getElementById('nextSongDisplay');
    if(nextEl){
        const nextSong=songs[currentIndex+1];
        nextEl.textContent=nextSong?`Next Up: ${currentIndex+2}. ${nextSong.title} - ${nextSong.artist}`:'';
    }
    const diffEl=document.getElementById('aheadBehind');
    if(diffEl){
        diffEl.style.color='';
        if(curSong){
            const setRemain = remainingDuration(true, elapsed);
            const maxSec = parseInt(document.getElementById('maxTime').value) * 60;
            const gigRemain = Math.max(0, maxSec - elapsed);
            let diff = gigRemain - setRemain;
            let text = 'On time';
            if(Math.abs(diff) >= 1){
                if(diff < 0){
                    text = `Behind ${formatTime(-diff)}`;
                    diffEl.style.color = 'red';
                }else{
                    text = `Ahead ${formatTime(diff)}`;
                    diffEl.style.color = 'blue';
                }
            }
            diffEl.textContent = text;
        }else{
            diffEl.textContent='';
        }
    }
    const clockEl=document.getElementById('clockTime');
    if(clockEl){
        clockEl.textContent=`Now: ${formatClock(new Date())}`;
    }
    const endEl=document.getElementById('projectedEnd');
    if(endEl){
        const rd=remainingDuration(true, elapsed);
        const endTime=new Date(Date.now()+rd*1000);
        endEl.textContent=`Setlist End: ${formatClock(endTime)}`;
    }
    const dropEl=document.getElementById('droppedInfo');
    if(dropEl){
        const count=songs.filter(s=>s.dropped).length;
        dropEl.textContent=`Dropped songs: ${count}`;
    }
    const transEl=document.getElementById('transitionInfo');
    if(transEl){
        const avg=transitionDurations.length?transitionDurations.reduce((a,b)=>a+b,0)/transitionDurations.length:0;
        transEl.textContent=`Avg transition: ${formatTime(avg)}`;
    }
    let shouldIndex=null;
    for(let i=0;i<songs.length;i++){
        if(elapsed < songs[i].start + songs[i].duration){
            shouldIndex=i;break;
        }
    }
    document.querySelectorAll('#setlist li').forEach(li=>li.classList.remove('playing','should','dropped'));
    const playLi=document.querySelector(`#setlist li[data-index="${currentIndex}"]`);
    if(playLi) playLi.classList.add('playing');
    if(shouldIndex!==null){
        const shouldLi=document.querySelector(`#setlist li[data-index="${shouldIndex}"]`);
        if(shouldLi) shouldLi.classList.add('should');
    }
    songs.forEach((song,i)=>{
        const li=document.querySelector(`#setlist li[data-index="${i}"]`);
        if(li){
            if(song.dropped) li.classList.add('dropped');
            else li.classList.remove('dropped');
            const cb=li.querySelector('.drop-toggle');
            if(cb) cb.checked=!song.dropped;
        }
    });
}

function startTimer(){
    if(timer) return;
    startTime=Date.now();
    isPaused=false;
    totalPause=0;

    const endInput=document.getElementById('endBy');
    if(endInput && endInput.value){
        const parts=endInput.value.split(':').map(Number);
        if(parts.length===2){
            const target=new Date(startTime);
            target.setHours(parts[0], parts[1], 0, 0);
            if(target.getTime()<startTime) target.setDate(target.getDate()+1);
            const minutes=Math.round((target.getTime()-startTime)/60000);
            const max=document.getElementById('maxTime');
            if(max) max.value=minutes;
        }
    }

    songStart=0;
    startDiff[0]=0;
    actualStart[0]=0;
    timer=setInterval(updateDisplay,1000/speedFactor);
    const toggle=document.getElementById('metronomeToggle');
    if(toggle && toggle.checked) startMetronome();
    updateButtonStates();
    updateDisplay();
}

function updateButtonStates(){
    const start=document.getElementById('startBtn');
    const stop=document.getElementById('stopBtn');
    if(!start || !stop) return;
    if(!startTime){
        start.textContent='Start';
        stop.disabled=true;
    }else if(isPaused){
        start.textContent='Resume';
        stop.disabled=false;
    }else{
        start.textContent='Pause';
        stop.disabled=false;
    }
}

function togglePause(){
    if(!startTime) return;
    if(isPaused){
        totalPause+=Date.now()-pauseStart;
        isPaused=false;
        timer=setInterval(updateDisplay,1000/speedFactor);
    }else{
        if(timer){
            clearInterval(timer);
            timer=null;
        }
        isPaused=true;
        pauseStart=Date.now();
    }
    updateButtonStates();
    updateDisplay();
}

function stopTimer(){
    if(!startTime) return;
    if(timer){
        clearInterval(timer);
        timer=null;
    }
    if(isPaused){
        totalPause+=Date.now()-pauseStart;
        isPaused=false;
    }
    stopMetronome();
    const elapsedSec=Math.floor(getElapsedMs()/1000*speedFactor);
    const pauseSec=Math.floor(totalPause/1000*speedFactor);
    let playedDur=0;
    for(let i=0;i<=currentIndex && i<songs.length;i++) playedDur+=songs[i].duration;
    const transitionSec=Math.max(0,elapsedSec-playedDur);
    alert(`Songs played: ${currentIndex+1}\nEstimated transition time: ${formatTime(transitionSec)}\nTime paused: ${formatTime(pauseSec)}`);
    currentIndex = 0;
    songStart = 0;
    startDiff.length = 0;
    actualStart.length = 0;
    startTime = null;
    totalPause = 0;
    updateButtonStates();
    updateDisplay();
}

document.getElementById('startBtn').addEventListener('click', () => {
    if(!startTime) startTimer();
    else togglePause();
});
document.getElementById('stopBtn').addEventListener('click', stopTimer);
document.getElementById('prevBtn').addEventListener('click', ()=>{
    currentIndex=Math.max(0,currentIndex-1);
    const elapsed=startTime?Math.floor(getElapsedMs()/1000):0;
    songStart=elapsed;
    startDiff[currentIndex]=elapsed - songs[currentIndex].start;
    actualStart[currentIndex]=elapsed;
    updateDisplay();
});
document.getElementById('nextBtn').addEventListener('click', () => {
    const elapsed = startTime ? Math.floor(getElapsedMs() / 1000) : 0;
    if (currentIndex < songs.length - 1) {
        if (actualStart[currentIndex] !== undefined) {
            const trans = elapsed - actualStart[currentIndex] - songs[currentIndex].duration;
            if (trans >= 0) transitionDurations[currentIndex] = trans;
        }
        currentIndex = Math.min(songs.length - 1, currentIndex + 1);
        songStart = elapsed;
        startDiff[currentIndex] = elapsed - songs[currentIndex].start;
        actualStart[currentIndex] = elapsed;
    }
    updateDisplay();
});
document.getElementById('transitionTime').addEventListener('change', renderSetlist);
document.getElementById('maxTime').addEventListener('change', () => {
    const elapsed = startTime ? Math.floor(getElapsedMs()/1000*speedFactor) : 0;
    if(autoDrop) computeDroppedSongs(elapsed);
    updateDisplay();
});
document.getElementById('dropBtn').addEventListener('click', ()=>{
    const elapsed=startTime ? Math.floor(getElapsedMs()/1000*speedFactor) : 0;
    computeDroppedSongs(elapsed);
    updateDisplay();
});
document.getElementById('autoDrop').addEventListener('change', e=>{
    autoDrop=e.target.checked;
    const elapsed=startTime ? Math.floor(getElapsedMs()/1000*speedFactor) : 0;
    if(autoDrop) computeDroppedSongs(elapsed);
    updateDropBtn(elapsed);
    updateDisplay();
});
document.getElementById('metronomeToggle').addEventListener('change', e=>{
    if(e.target.checked) startMetronome();
    else stopMetronome();
});
document.getElementById('bpmInput').addEventListener('change', e=>{
    const val=parseInt(e.target.value);
    if(!isNaN(val) && val>0){
        setMetronomeBpm(val);
    }
});
updateDropBtn(0);
</script>
</body>
</html>
