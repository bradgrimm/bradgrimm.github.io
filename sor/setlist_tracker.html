<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>School of Rock Setlist Tracker</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
 <style>
  body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
  }
  .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.1);
      padding: 20px;
  }
  h1 {
      text-align:center;
      margin-bottom:15px;
      font-weight:300;
  }
  #timerDisplay {
      font-size:3em;
      font-weight:bold;
      text-align:center;
      display:block;
      margin:10px 0;
  }
  #currentSongDisplay {
      font-size:2.2em;
      font-weight:bold;
      text-align:center;
      margin:20px 0 5px;
  }
  #nextSongDisplay {
      font-size:1.3em;
      text-align:center;
      margin-bottom:15px;
      color:#555;
  }
  #progressContainer {
      height:20px;
      background:#e2e8f0;
      border-radius:10px;
      overflow:hidden;
      margin:10px 0;
  }
  #progressBar {
      height:100%;
      width:0%;
      background:#4caf50;
      transition:width 0.2s ease;
  }
  #aheadBehind {
      text-align:center;
      font-size:1.5em;
      margin:10px 0;
  }
  #clockTime,#projectedEnd,#droppedInfo,#transitionInfo{
      text-align:center;
      margin:4px 0;
      font-size:1em;
  }
  #setlist { list-style:none; padding:0; }
  #setlist li {
      padding:12px;
      background:#f9f9f9;
      margin-bottom:8px;
      border-radius:8px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      box-shadow:0 2px 4px rgba(0,0,0,0.05);
  }
  #setlist li.playing { background:#fff3cd; }
  #setlist li.should { background:#d1e7dd; }
  #setlist li.dropped { background:#f8d7da; text-decoration: line-through; opacity:0.6; }
.song-info { flex:1; }
.drop-label { margin-left:10px; font-size:0.9em; }
.protect-label { margin-left:10px; font-size:0.9em; }
.time { width:60px; text-align:right; margin-left:10px; }
 .runtime { width:60px; text-align:right; margin-left:10px; }
.remove { margin-left:10px; }
  #navControls{
      text-align:center;
      margin-bottom:15px;
  }
  #navControls button{
      font-size:1.5em;
      padding:15px 25px;
      margin:0 5px;
      background:#4caf50;
      color:white;
      border:none;
      border-radius:8px;
      cursor:pointer;
  }
  #navControls button:active{
      transform:scale(0.97);
  }
  #fileControls{
      margin-top:20px;
      text-align:center;
  }
  #fileControls label{
      margin-left:10px;
      font-size:1.1em;
  }
  #fileControls input[type="number"]{
      width:4em;
  }
  @media (max-width:600px){
      #navControls button{
          font-size:1.2em;
          padding:12px 20px;
      }
      #currentSongDisplay{ font-size:1.6em; }
      #nextSongDisplay{ font-size:1.1em; }
  }
</style>
</head>
<body>
<div class="container">
<h1>Setlist Tracker</h1>
<div id="navControls">
    <button id="startBtn">Start</button>
    <button id="pauseBtn">Pause</button>
    <button id="stopBtn">Stop</button>
    <button id="prevBtn">&lt;</button>
    <button id="nextBtn">&gt;</button>
</div>
<div id="currentSongDisplay"></div>
<div id="nextSongDisplay"></div>
<div id="progressContainer"><div id="progressBar"></div></div>
<span id="timerDisplay">00:00</span>
<div id="timeRemaining" style="text-align:center;margin-bottom:10px;"></div>
<div id="aheadBehind"></div>
<div id="clockTime"></div>
<div id="projectedEnd"></div>
<div id="droppedInfo"></div>
<div id="transitionInfo"></div>
<ul id="setlist"></ul>
<div id="fileControls">
    <input type="file" id="csvFile" accept=".csv">
    <label>Max Time (min): <input type="number" id="maxTime" value="60" min="1"></label>
    <label>End By: <input type="time" id="endBy"></label>
    <label>Transition (sec): <input type="number" id="transitionTime" value="60" min="0"></label>
</div>
</div>
<script>
let songs = [];
let timer = null;
let startTime = null;
let currentIndex = 0;
let speedFactor = 1;
let songStart = 0; // actual start time (sec) of the current song
const startDiff = []; // difference of actual start vs scheduled start per song
let isPaused = false;
let pauseStart = 0;
let totalPause = 0; // accumulated pause time in ms
const actualStart = [];
const transitionDurations = [];

// Check query string for a debugging speed multiplier, e.g. ?debugspeed=5
// This is intentionally hidden so regular users don't accidentally change it.
const params = new URLSearchParams(window.location.search);
const dbg = parseFloat(params.get('debugspeed'));
if(dbg && dbg > 0) speedFactor = dbg;

function parseDuration(str){
    if(!str) return 0;
    str = String(str).trim();
    if(str.includes(':')){
        const parts = str.split(':').map(Number);
        if(parts.length===2){
            return parts[0]*60 + parts[1];
        } else if(parts.length===3){
            return parts[0]*3600 + parts[1]*60 + parts[2];
        }
    }
    if(/^[0-9.]+$/.test(str)) return parseFloat(str)*60;
    return 0;
}

function formatTime(sec){
    sec = Math.max(0, Math.floor(sec));
    const m = Math.floor(sec/60);
    const s = sec%60;
    return `${m}:${s.toString().padStart(2,'0')}`;
}

function getElapsedMs(){
    if(!startTime) return 0;
    let paused = totalPause;
    if(isPaused) paused += Date.now()-pauseStart;
    return Date.now() - startTime - paused;
}
  

function formatClock(date){
    return date.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
}

document.getElementById('csvFile').addEventListener('change', e=>{
    const file = e.target.files[0];
    if(!file) return;
    Papa.parse(file, {
        header:true,
        skipEmptyLines:true,
        complete: res => { loadSongs(res.data); }
    });
});

function loadSongs(data){
    songs = [];
    if(timer){
        clearInterval(timer);
        timer=null;
    }
    startTime=null;
    isPaused=false;
    totalPause=0;
    currentIndex=0;
    data.forEach(row=>{
        const normalized = {};
        Object.keys(row).forEach(k=>{
            normalized[k.trim().toLowerCase()] = row[k];
        });
        const title = normalized['song'] || normalized['title'];
        const artist = normalized['artist'];
        const durField = normalized['duration'] || normalized['time'];
        if(!title && !artist) return; // ignore note rows
        songs.push({
            title: title || '',
            artist: artist || '',
            duration: parseDuration(durField),
            dropFirst:false,
            dropNum:1,
            start:0,
            protect:false
        });
    });
    renderSetlist();
    updateDisplay();
}

function renderSetlist(){
    const list=document.getElementById('setlist');
    list.innerHTML='';
    let cumulative=0;
    const transition=parseInt(document.getElementById('transitionTime').value)||0;
    songs.forEach((song,i)=>{
        song.start=cumulative;
        cumulative+=song.duration+transition;
        const li=document.createElement('li');
        li.dataset.index=i;
        li.innerHTML=`<span class="song-info">${i+1}. ${song.title} - ${song.artist}</span>
            <span class="runtime">${formatTime(song.start)}</span>
            <span class="time">${formatTime(song.duration)}</span>
            <label class="drop-label"><input type="checkbox" class="drop" data-idx="${i}" ${song.dropFirst?'checked':''}> drop <input type="number" class="drop-num" data-idx="${i}" min="1" value="${song.dropNum}" style="width:3em" ${song.dropFirst?'':'disabled'}></label>
            <label class="protect-label"><input type="checkbox" class="protect" data-idx="${i}" ${song.protect?'checked':''}> keep</label>
            <button class="remove" data-idx="${i}">Remove</button>`;
        list.appendChild(li);
    });
    document.querySelectorAll('.drop').forEach(cb=>{
        cb.addEventListener('change',e=>{
            const idx=parseInt(e.target.dataset.idx);
            songs[idx].dropFirst=e.target.checked;
            const num=document.querySelector(`.drop-num[data-idx="${idx}"]`);
            if(num){
                num.disabled=!e.target.checked;
                if(e.target.checked && !num.value) num.value=songs[idx].dropNum;
            }
        });
    });
    document.querySelectorAll('.protect').forEach(cb=>{
        cb.addEventListener('change',e=>{
            const idx=parseInt(e.target.dataset.idx);
            songs[idx].protect=e.target.checked;
        });
    });
    document.querySelectorAll('.drop-num').forEach(inp=>{
        inp.addEventListener('change',e=>{
            const idx=parseInt(e.target.dataset.idx);
            const val=parseInt(e.target.value);
            if(!isNaN(val)) songs[idx].dropNum=val;
        });
    });
    document.querySelectorAll('.remove').forEach(btn=>{
        btn.addEventListener('click',e=>{
            const idx=parseInt(e.target.dataset.idx);
            songs.splice(idx,1);
            renderSetlist();
        });
    });
    document.getElementById('timeRemaining').textContent='';
    updateDisplay();
}

function computeDroppedSongs(elapsed){
    const maxSec=parseInt(document.getElementById('maxTime').value)*60;
    const remaining=maxSec-elapsed;
    const transition=parseInt(document.getElementById('transitionTime').value)||0;

    songs.forEach(s=>s.dropped=false);

    const pending=[];
    for(let i=currentIndex;i<songs.length;i++) pending.push(i);
    const droppable=pending.filter(i=>!songs[i].protect);

    const totalDur=idxs=>{
        let t=0;
        for(let j=0;j<idxs.length;j++){
            t+=songs[idxs[j]].duration;
            if(j<idxs.length-1) t+=transition;
        }
        return t;
    };

    let keep=[...pending];
    if(totalDur(keep)<=remaining) return;

    const dropFirst=droppable.filter(i=>i!==0 && i!==songs.length-1 && songs[i].dropFirst)
        .sort((a,b)=>{
            const d=(songs[a].dropNum||0)-(songs[b].dropNum||0);
            return d!==0?d:b-a;
        });
    const untagged=droppable.filter(i=>i!==0 && i!==songs.length-1 && !songs[i].dropFirst)
        .sort((a,b)=>b-a);
    const anchors=droppable.filter(i=>i===0 || i===songs.length-1)
        .sort((a,b)=>b-a);

    const lists=[dropFirst,untagged,anchors];
    for(const list of lists){
        while(list.length && totalDur(keep)>remaining){
            const idx=list.shift();
            keep=keep.filter(k=>k!==idx);
            songs[idx].dropped=true;
        }
    }
}

function remainingDuration(withDrops, elapsed){
    const transition=parseInt(document.getElementById('transitionTime').value)||0;
    const remainIdx=[];
    for(let i=currentIndex;i<songs.length;i++){
        if(withDrops && songs[i].dropped) continue;
        remainIdx.push(i);
    }
    let t=0;
    const progress=Math.max(0, elapsed - songStart);
    remainIdx.forEach((idx,j)=>{
        let dur=songs[idx].duration;
        if(idx===currentIndex) dur=Math.max(0,dur-progress);
        t+=dur;
        if(j<remainIdx.length-1) t+=transition;
    });
    return t;
}

function updateDisplay(){
    const elapsed=startTime ? Math.floor(getElapsedMs()/1000*speedFactor) : 0;
    computeDroppedSongs(elapsed);
    document.getElementById('timerDisplay').textContent=formatTime(elapsed);
    const maxSec=parseInt(document.getElementById('maxTime').value)*60;
    document.getElementById('timeRemaining').textContent='Remaining: '+formatTime(maxSec-elapsed);
    const progress=document.getElementById('progressBar');
    if(progress){
        progress.style.width=Math.min(100,elapsed/maxSec*100)+"%";
    }
    const curSong=songs[currentIndex];
    const songEl=document.getElementById('currentSongDisplay');
    if(songEl){
        songEl.textContent=curSong?`${currentIndex+1}. ${curSong.title} - ${curSong.artist}`:'';
    }
    const nextEl=document.getElementById('nextSongDisplay');
    if(nextEl){
        const nextSong=songs[currentIndex+1];
        nextEl.textContent=nextSong?`Next Up: ${currentIndex+2}. ${nextSong.title} - ${nextSong.artist}`:'';
    }
    const diffEl=document.getElementById('aheadBehind');
    if(diffEl){
        if(curSong){
            diffEl.style.color='';

            const progress=Math.max(0,elapsed-songStart);
            const delta=startDiff[currentIndex] ?? (elapsed-curSong.start);
            const diff=delta*(curSong.duration?Math.min(progress/curSong.duration,1):1);

            if(Math.abs(diff)<1){
                diffEl.textContent='On time';
            }else if(diff>0){
                diffEl.textContent=`Behind ${formatTime(diff)}`;
                diffEl.style.color='goldenrod';
            }else{
                diffEl.textContent=`Ahead ${formatTime(-diff)}`;
                diffEl.style.color='blue';
            }
        }else{
            diffEl.textContent='';
        }
    }
    const clockEl=document.getElementById('clockTime');
    if(clockEl){
        clockEl.textContent='Current: '+formatClock(new Date());
    }
    const endEl=document.getElementById('projectedEnd');
    if(endEl){
        const rd=remainingDuration(true, elapsed);
        const ra=remainingDuration(false, elapsed);
        const endDrop=new Date(Date.now()+rd*1000/speedFactor);
        const endAll=new Date(Date.now()+ra*1000/speedFactor);
        endEl.textContent=`End w/drops: ${formatClock(endDrop)} | w/out: ${formatClock(endAll)}`;
    }
    const dropEl=document.getElementById('droppedInfo');
    if(dropEl){
        const count=songs.filter(s=>s.dropped).length;
        dropEl.textContent=`Dropped songs: ${count}`;
    }
    const transEl=document.getElementById('transitionInfo');
    if(transEl){
        const avg=transitionDurations.length?transitionDurations.reduce((a,b)=>a+b,0)/transitionDurations.length:0;
        transEl.textContent=`Avg transition: ${formatTime(avg)}`;
    }
    let shouldIndex=null;
    for(let i=0;i<songs.length;i++){
        if(elapsed < songs[i].start + songs[i].duration){
            shouldIndex=i;break;
        }
    }
    document.querySelectorAll('#setlist li').forEach(li=>li.classList.remove('playing','should','dropped'));
    const playLi=document.querySelector(`#setlist li[data-index="${currentIndex}"]`);
    if(playLi) playLi.classList.add('playing');
    if(shouldIndex!==null){
        const shouldLi=document.querySelector(`#setlist li[data-index="${shouldIndex}"]`);
        if(shouldLi) shouldLi.classList.add('should');
    }
    songs.forEach((song,i)=>{
        const li=document.querySelector(`#setlist li[data-index="${i}"]`);
        if(li && song.dropped) li.classList.add('dropped');
    });
}

function startTimer(){
    if(timer) return;
    startTime=Date.now();
    isPaused=false;
    totalPause=0;

    const endInput=document.getElementById('endBy');
    if(endInput && endInput.value){
        const parts=endInput.value.split(':').map(Number);
        if(parts.length===2){
            const target=new Date(startTime);
            target.setHours(parts[0], parts[1], 0, 0);
            if(target.getTime()<startTime) target.setDate(target.getDate()+1);
            const minutes=Math.round((target.getTime()-startTime)/60000);
            const max=document.getElementById('maxTime');
            if(max) max.value=minutes;
        }
    }

    songStart=0;
    startDiff[0]=0;
    actualStart[0]=0;
    timer=setInterval(updateDisplay,1000/speedFactor);
    updateDisplay();
}

function togglePause(){
    if(!startTime) return;
    const btn=document.getElementById('pauseBtn');
    if(isPaused){
        totalPause+=Date.now()-pauseStart;
        isPaused=false;
        timer=setInterval(updateDisplay,1000/speedFactor);
        if(btn) btn.textContent='Pause';
    }else{
        if(timer){
            clearInterval(timer);
            timer=null;
        }
        isPaused=true;
        pauseStart=Date.now();
        if(btn) btn.textContent='Resume';
    }
    updateDisplay();
}

function stopTimer(){
    if(!startTime) return;
    if(timer){
        clearInterval(timer);
        timer=null;
    }
    if(isPaused){
        totalPause+=Date.now()-pauseStart;
        isPaused=false;
        const btn=document.getElementById('pauseBtn');
        if(btn) btn.textContent='Pause';
    }
    const elapsedSec=Math.floor(getElapsedMs()/1000*speedFactor);
    const pauseSec=Math.floor(totalPause/1000*speedFactor);
    let playedDur=0;
    for(let i=0;i<=currentIndex && i<songs.length;i++) playedDur+=songs[i].duration;
    const transitionSec=Math.max(0,elapsedSec-playedDur);
    alert(`Songs played: ${currentIndex+1}\nEstimated transition time: ${formatTime(transitionSec)}\nTime paused: ${formatTime(pauseSec)}`);
}

document.getElementById('startBtn').addEventListener('click', startTimer);
document.getElementById('pauseBtn').addEventListener('click', togglePause);
document.getElementById('stopBtn').addEventListener('click', stopTimer);
document.getElementById('prevBtn').addEventListener('click', ()=>{
    currentIndex=Math.max(0,currentIndex-1);
    const elapsed=startTime?Math.floor(getElapsedMs()/1000):0;
    songStart=elapsed;
    startDiff[currentIndex]=elapsed - songs[currentIndex].start;
    actualStart[currentIndex]=elapsed;
    updateDisplay();
});
document.getElementById('nextBtn').addEventListener('click', () => {
    const elapsed = startTime ? Math.floor(getElapsedMs() / 1000) : 0;
    if (currentIndex < songs.length - 1) {
        if (actualStart[currentIndex] !== undefined) {
            const trans = elapsed - actualStart[currentIndex] - songs[currentIndex].duration;
            if (trans >= 0) transitionDurations[currentIndex] = trans;
        }
        currentIndex = Math.min(songs.length - 1, currentIndex + 1);
        songStart = elapsed;
        startDiff[currentIndex] = elapsed - songs[currentIndex].start;
        actualStart[currentIndex] = elapsed;
    }
    updateDisplay();
});
document.getElementById('transitionTime').addEventListener('change', renderSetlist);
</script>
</body>
</html>
